---
layout: post
title:  "Sef4J : Simple Event Facade for Java : Library for Performance Monitoring - Events - Metrics Aggregator"
date:   2015-04-10 11:00:00
categories: 
tags: performance monitoring github projects
---


<h1>Sef4j - Name and motivation</h1>

Sef4j stands as initials for "Simple Event Facade for Java"
It tries to offer a simple API for Events and Monitoring, as simple as slf4j (previously Log4J) is to Log.
Maybe "Semf4j" would be a more appropriate name?

Another project name could have been "Performance Monitoring Facade 4 Java" : perf4j, but the name is already registered.
see https://github.com/perf4j/perf4j
Unfortunatly, the project seems to do very few things compared to mine (maybe a pull request for them?).

Sef4j, is a "yet-another" performance monitoring framework, which has now many free/commercial equivalent.
Open source "equivalent framework" would be Dropwizard Metrics (formely Codahale Metrics), JavaMelody, or many other...
Commercial equivalent are ultra impressives (and ultra expensive...).
<p/>


<h1>Difference with DropWizard Metrics : Tree of Statistics Counters</h1>

The big differences with Sef4j compared to Dropwizard Metrics is that Sef4j captures applicative stack traces, not flat traces counters like Metrics.
But it also allows you to manually instrument applicative parameters that make sense in your business code, and use them to categorize differents types of counters for the same stack trace. For example in a financial application, you may want to have several counters for the same pricing method depending of the portfolio used, instruments, thirdparties... because different rules are used to dispatch to different algorithms and data repositories. 
<p/>

Counters may be in-memory tree, that aggregate events with predefined or user-defined listener code. 
<br/>
The framework for instrumenting follows open-close principles! ... If offers you events for push() and pop() for every instrumented methods, you are free to treat these events for aggregating what make sense, and producing counter, histograms, alerts, events, logs... 
<p/>

Here is a typical example showing a tree of statistic counters, compared to flat statistic list as in Dropwizard Metrics.<br/>
Say you have 2 entry points Web services, internally calling several services, and then DAOs jdbc queries.

In Dropwizard Metrics, you would instrument it like that:
{% highlight java %}
public class MyWebService {
   @Timed
   public MyResult myService1(param1, param2...) {
      dao.myQuery1(..)
   }
   @Timed
   public MyResult myService2(param1, param2...) {
      dao.myQuery1(..)
      dao.myQuery2(..)      
   }
}

public class MyDAO {
   @Timed
   public MyResult myQuery1(param1, param2...) {
      jdbc / jpa query...
   }
   @Timed
   public MyResult myQuery2(param1, param2...) {
      jdbc / jpa query...
   }
}
{% endhighlight %}

In DropWizard Metrics, You will get 4 flat metric counters:
{% highlight text %}
MyWebService.myServices1  --> counter stats, ..
MyWebService.myServices2  --> counter stats, ..
MyDAO.myQuery1  --> counter stats, ..
MyDAO.myQuery2  --> counter stats, ..
{% endhighlight %}

How can you known how are linked performance problems in DAO.myQuery1 and MyWebService entrypoint 1/2 ?.. You can't.
In Sef4j as in many J2EE profiler tools, you will get a tree of performance counters

{% highlight text %}
/
+-- MyWebService.myServices1  --> counter stats, ..
|     |
|     +-- MyDAO.myQuery1  --> counter stats, ..
|     +-- MyDAO.myQuery2  --> counter stats, ..
|
+-- MyWebService.myServices2  --> counter stats, ..
      |
      +-- MyDAO.myQuery1  --> counter stats, ..
      +-- MyDAO.myQuery2  --> counter stats, ..   
{% endhighlight %}


If you still want to show a flat list of counters from this rich tree data structure, you can: it is only a matter of grouping and summing per node name.

{% highlight text %}
sum(**/MyDAO.myQuery1) =   
     MyWebService.myServices1/MyDAO.myQuery1
   + MyWebService.myServices2/MyDAO.myQuery1
{% endhighlight %}


<h1>Instrumented Method - Applicative Stack Trace - Applicative Tree Path</h1>

What I call "Applicative Stack Trace" is the filtering of the real java stack trace when preserving only nodes of interrests : your annotated/instrumented methods, not all this java.lang.*, com.sun.reflect.*, org.springframework.* intermediates nodes you have... 

{% highlight text %}
at myapp.MyDAO
at myapp.MyWebService
{% endhighlight %}

instead of 

{% highlight text %}
at com.oracle.driver...
at org.sef4j ...
at org.hibernate...
at org.springframework...
at java.lang.reflect..
at 
at myapp.MyDAO
at 
at myapp.MyWebService
at ..
at org.springframework
at javax.servlet..
at tomcat..
{% endhighlight %}


With Sef4j, you can instrument method basically by putting a pre()/post() aspect within your method
 
{% highlight java %}
public class MyWebService {

   @Sef4jAspect // <== using whatever AOP framework (Aspectj, ...)
   public MyResult myService1(param1, param2...) {
      ...
   }
   
}
{% endhighlight java %}

If you prefer, you can write the equivalent java code yourself, 
which is exactly 2 lines (+ 1 line for import) for jdk8, 5 lines for jdk < 8:

{% highlight java %}
import org.sef4j.callstack.LocalCallStack;

public class MyWebService {

 /** instrumented code with sef4j, using jdk8 Closeable try-finally */
 public MyResult myService1(param1, param2...) {
   try (StackPopper toPop = LocalCallStack.meth("MyWebService", "myService1").push()) {
      ...
   }
 }
 /** instrumented code with sef4j, using explicit try-finally (jdk<8) */
 public MyResult myService1(param1, param2...) {
   StackPopper toPop = LocalCallStack.meth("MyWebService", "myService1").push();
   try {
      ...
   } finally {
      toPop.close();
   }
 }
}
{% endhighlight java %}


you can enrich your method instrumentation : you have a fluent api to build information on the current method of the current thread, put info in it, then call push().


{% highlight java %}
StackPopper toPop = LocalCallStack.method("MyWebService", "myService1")
        .withParam("param1", param1) // <= add method parameter info
        .withInheritedProp("param2", param2) // <= add inherited property (will be available as ThreadLocal for all child calls)
        .withLog(LOG, false, 300) // <= no log in push(), log in pop() only if time exceed 300 ms
        .withProgressExpectedCount(20) // <= expected 20 progress steps in a loop 
        .push();
        
{% endhighlight %}


Pushed method don't have to be real method, virtual nodes can be introduced to split counters per applicative criteria
{% highlight java %}
public class MyWebService {
   public MyResult myService1(param1, param2...) {
		try(AppCallStack.method("myService").WithParam("param1", param1).push())   // ==> attach inherited property to current Thread
			try (AppCallStack.method("perParam:" + param1)) {
			
				MyDAO.myQuery1()
				..
			} // => finally pop("perParam")
		}// => finally... pop("myService")
   }
}
{% endhighlight %}

You will get a tree of stat counter like


{% highlight text %}
/
+-- MyWebService.myServices1  --> counter stats, ..
|     |
|     +-- perParam1:value1
|     |    +-- MyDAO.myQuery1  --> counter stats, ..
|     |    +-- MyDAO.myQuery2  --> counter stats, ..
|     +-- perParam1:value2
|     |    +-- MyDAO.myQuery1  --> counter stats, ..
|     |    +-- MyDAO.myQuery2  --> counter stats, ..
|     +-- perParam1:value3
|     |    +-- MyDAO.myQuery1  --> counter stats, ..
|     |    +-- MyDAO.myQuery2  --> counter stats, ..
|     ...
{% endhighlight %}



